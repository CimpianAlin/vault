# Principles of using the Brave Vault
The _Brave vault_ is a mediation server for your browsing activities as they relate to advertisements.
It is carefully designed so as to "know" as little as possible about you and your browsing habits.
In order to understand the limitations of this design,
we need to examine the basic principles of the vault.

## Personas and Sessions
The central data element in the vault is a _persona_ -- sometimes referred to as a _user_ of the system.
A persona is meant to identify a set of your browsing behaviors,
without identifying you.
Each Brave-capable browser is free to create its own persona,
or to use an existing persona created by another browser.

If you configure the same persona for multiple browsers
(e.g., your desktop at work, your tablet at home, your phone when mobile),
then this provides a more complete picture of your browsing activities.
You may view this as a good thing or a bad thing -- and that's fine -- you decide.

### Creating a Persona
The `PUT /v1/users/{userId}` operation both
creates an entry for a persona,
and updates the information in that entry.
A `userId` is a 122-bit pseudo-random number commonly known as a
[UUID v4](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_.28random.29) value.
Note that it is generated by the browser,
not the server.
For example,
[Stack Overflow](http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript#2117523)
gives a browser-based example:

    'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = window.crypto.getRandomValues(new Uint8Array(1))[0]%16|0, v = c == 'x' ? r : (r&0x3|0x8)
        return v.toString(16).toUpperCase()
    })

In addition to generating the `userId`,
the browser generates a `masterKey` and a `signingPair`, perhaps using something like:

    window.crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true
                                    , ["encrypt", "decrypt"]).then(function (masterKey) { ... })

    window.crypto.subtle.generateKey({ name: "ECDSA", namedCurve: "P-256" }, true
                                    , [ "sign", "verify" ]).then(function (signingPair) { ... })

Both the `masterKey` and `signingPair.private` must be securely persisted in the browser.

When creating a persona,
the body of the operation is:

    { envelope     :
      { version    : 1
      , privateKey : '...'
      , iv         : '...'
      , publicKey  : '...'
      }
    }

The `version` property is self-explanatory.

The `privateKey` and `iv` properties are used to describe an encrypted `cipherKey`,
that is used to encrypt the symmetric key associated with a given "blob".
The `publicKey` property is the hexadecimal string representation of the public key used to verify digital signatures.
The vault verifies the signature as the authorization check for an operation.

    var to_hex = function (bs) {
        var encoded = []
        
        for (var i = 0; i < bs.length; i++) {
            encoded.push("0123456789abcdef"[(bs[i] >> 4) & 15])
            encoded.push("0123456789abcdef"[bs[i] & 15])
        }
        return encoded.join('')
    }
        
    var ab2b = function (ab) {
        var buffer = []
        var view = new Uint8Array(ab)
        
        for (var i = 0; i < ab.byteLength; i++) buffer[i] = view[i]
        return buffer
    }
        
        
    window.crypto.subtle.exportKey('raw', pair.publicKey).then(function (publicKey) {

        window.crypto.subtle.generateKey({ name: "AES-GCM", length: 256 },
                                         true, ["encrypt", "decrypt"]).then(function (cipherKey) {

            window.crypto.subtle.exportKey('raw', cipherKey).then(function (exportKey) {
                exportKey = ab2b(exportKey)
        
                // cipherKey is now encrypted using the masterKey that is stored on the browser
                var iv = window.crypto.getRandomValues(new Uint8Array(12))
                window.crypto.subtle.encrypt({ name: "AES-GCM", iv: iv },
                                             masterKey, new Uint8Array(exportKey)).then(function (privateKey) {
                    console.log('PUT /users/' + personaID)
                    console.log(JSON.stringify({
                        envelope       :
                          { version    : 1
                          , privateKey : to_hex(ab2b(privateKey))
                          , iv         : to_hex(iv)
                          , publicKey  : to_hex(ab2b(publicKey))
                          }
                      }, null, 2))
                })
            })
        })
    })

To summarize,

* Whenever the browser stores something encrypted in the vault,
it uses the `cipherKey` for this purpose.
By storing the encrypted `cipherKey` in the vault,
other browsers -- that you configure to be authorized -- are able to retrieve the encrypted value and then derive the actual
value of the key.

* Whenever the browser stores something in the vault,
it uses the `signingPair.privateKey` to generate a signature over a hashed value to allow the vault to determine if
the browser is authorized.

### Creating a Session
In addition to selecting a persona,
a browser must also create a _session_.
As with the `userId`,
a `sessionId` is a UUID v4 string that is generated by the browser.

Although the browser determines the lifetime of the session -- the common practice is to generate just once.
The reason is that the `sessionId` may be used as a key to store browser-specific information such as history.

Sessions are implicitly created when the browser uses 
The `PUT /v1/users/{userId}/sessions/{sessionId}/types/{type}` operation
creates or updates that `type` of information for that particular session of the persona.


### Joining a Persona
When the user wishes to configure an additional browser (the "new" browser) to use the same persona,
the "new" browser needs to be told:

* the persona-identifier (`userId`)

* the `masterKey`

* the `signingPair.privateKey`

The easiest way to do this is to have a browser that already knows about the persona (the "old" browser)
generate a [QR code](https://en.wikipedia.org/wiki/QR_code) of the form:

    brave://vault/persona/{userId}?m={masterkey}&p={signingPair.privateKey}

perhaps by using code that looks like this:

    var url = 'brave://vault/persona/' + personaID
    window.crypto.subtle.exportKey('raw', masterKey).then(function (exportKey) {
        url += '?m=' + ab2b(exportKey)

        // @yan - this always throws an error in FF -- NotSupportedError: Operation is not supported
        // any ideas?
        window.crypto.subtle.exportKey('raw', pair.privateKey).then(function (privateKey) {
            url += '?p=' + ab2b(privateKey)

            console.log('QR code: ' + url)
        })
    })

Once the QR code is generated,
the "new" browser can use its camera and a QR decoder to derive the three elements pertaining to the persona.
The "new" browser uses the `GET /v1/users/{userId}` operation to retrieve the `envelope.privateKey` value,
which allows it to decipher the `masterKey` for the persona.

(Of course,
instead of using a QR code,
the "old" browser could display the three values,
and the "new" browser could allow the user to enter this information manually.
Just kidding -- that's far too much error-prone typing for a person!)

## Managing State
The vault manages two kinds of state:

* local state, that is session-specific

* global state, that is session-independent

It is up to the browser to determine which kind of state to associated with browser-specific data.

### Local State
The `GET /v1/users/{userId}/sessions` operation returns an array of all local state for the persona.
Because there may be many results,
the operation has two optional `GET query` parameters,
`limit` and `timestamp`.

The `limit` parameter indicates the maximum number of entries to return.

The `timestamp` parameter is an opaque string.
On the first call to `GET /v1/users/{userId}/sessions`,
the parameter isn't specified.
On subsequent calls,
the value should be equal to the `timestamp` property of the final element in the results array.
Eventually,
the results array will be zero-length,
and all entries have been returned.

The `GET /v1/users/{userId}/sessions/{sessionId}/types` operation returns an array of all local state for a particular
session of the persona.
The operation has two optional `GET query` parameters,
`limit` and `timestamp`,
with the usual semantics.

The `GET /v1/users/{userId}/sessions/{sessionId}/types/{type}` operation returns the local state of for a particular
`type` of information for that particular session of the persona.

The `PUT /v1/users/{userId}/sessions/{sessionId}/types/{type}` operation creates or updates that `type` of information for
that particular session of the persona.

When upserting state information,
the body of the operation is:

    { envelope      :
      { signature   : '...'
      , nonce       : '...'
      },
    , payload       :
      { privateKey  : '...'
      , iv          : '...'
      , privateData : '...'
      }
    }

For example:

    var b2ab = function (b) {
        var array = new ArrayBuffer(b.length)
        var buffer = new Uint8Array(array)

        for (var i = 0; i < b.length; i++) buffer[i] =b.charCodeAt(i)
        return array
    }

    var history = { ... }
    window.crypto.subtle.generateKey({ name: "AES-GCM", length: 256 },
                                     true, ["encrypt", "decrypt"]).then(function (symmetricKey) {
        // each "blob" of state is encrypted using a new key

        window.crypto.subtle.exportKey('raw', symmetricKey).then(function (exportKey) {
            exportKey = ab2b(exportKey)

            var iv = window.crypto.getRandomValues(new Uint8Array(12))
            // that blob-specific key is now encrypted using the cipherKey
            window.crypto.subtle.encrypt({ name: "AES-GCM", iv: iv },
                                         cipherKey, new Uint8Array(exportKey)).then(function(privateKey) {
                var message = { envelope     : {}
                              , payload      :
                                { privateKey : to_hex(ab2b(privateKey))
                                , iv         : to_hex(iv)
                                }
                              }
                window.crypto.subtle.encrypt({ name: "AES-GCM", iv: iv },
                                             symmetricKey, b2ab(JSON.stringify(history))).then(function(privateData) {
                    message.payload.privateData = to_hex(ab2b(privateData))

                    var nonce = window.crypto.getRandomValues(new Uint8Array(12))
                    var combo = JSON.stringify(personaID + ':' + to_hex(nonce) + ':' + JSON.stringify(message.payload))
                    window.crypto.subtle.sign({ name: "ECDSA", hash: { name: "SHA-256" } },
                                              pair.privateKey, b2ab(combo)).then(function(signature) {
                        message.envelope = { signature: to_hex(ab2b(signature))
                                           , nonce: to_hex(nonce)
                                           }

                        console.log('PUT /users/' + personaID + '/sessions/' + sessionID
                                    + '/types/history')
                        console.log(JSON.stringify(message, null, 2))
                    })
                })
            })
        })
    })

In some cases,
the browser may want the vault to be able to see the contents:

    var message = { envelope    : {}
                  , payload     : 
                    { sessionId : sessionID
                    , type      : "browser.app.launch"
                    , timestamp : new Date().getTime()
                    , data      : {}
                    }
                  }
    var nonce = window.crypto.getRandomValues(new Uint8Array(12))
    var combo = JSON.stringify(personaID + ':' + to_hex(nonce) + ':' + JSON.stringify(message.payload))
    window.crypto.subtle.sign({ name: "ECDSA", hash: { name: "SHA-256" } },
                              pair.privateKey, b2ab(combo)).then(function(signature) {
        message.envelope = { signature: to_hex(ab2b(signature))
                           , nonce: to_hex(nonce)
                           }

        console.log('POST /users/' + personaID + '/intents')
        console.log(JSON.stringify(message, null, 2))
    })

Note that in both cases,
the vault verifies the digital signature in order to ensure that the operation is authorized.

### Global State
The `PUT /v1/users/{userId}` operation,
in addition to creating an entry for a persona,
also updates the information in that entry.

When updating information,
the body of the operation is:

    { timestamp     : '...'
    , envelope      :
      { signature   : '...'
      , nonce       : '...'
      },
    , payload       :
      { privateKey  : '...'
      , iv          : '...'
      , privateData : '...'
      , publicData  : { ... }
      }
    }

The procedure for generating the `envelope` and `payload` properties are the same,
with one exception: there is both a `payload.privateData` property and a `payload.publicData` property.
The latter is an arbitrary JSON object with plaintext information.

The `timestamp` property is used to implement an advisory locking scheme.
This operation updates information shared between all applications for the correpsonding user entry. To successfully update the shared information, the browser must:

1. Use the `GET /v1/users/{userId}` operation to retrieve the current information; then,

2. Modify the returned "payload" as appropriate; then,

3. Use the `PUT /v1/users/{userId}` operation with the previously-returned `timestamp` and the modified `payload`.

4. If HTTP code 422 is returned, go back to Step 1; otherwise,

5. Optionally:
locally persist the newly-returned `timsetamp`
so as to skip Step 1 the next time a state update is desired.

This allows multiple applications to (patiently) coordinate their actions in upgrading the shared information.
However, if an application must universally overwrite the shared information, it omits the "timestamp" parameter.

    var publicGlobal = { ... }
    var privateGlobal = { ... }
    window.crypto.subtle.generateKey({ name: "AES-GCM", length: 256 },
                                     true, ["encrypt", "decrypt"]).then(function (symmetricKey) {
        window.crypto.subtle.exportKey('raw', symmetricKey).then(function (exportKey) {
            exportKey = ab2b(exportKey)

            var iv = window.crypto.getRandomValues(new Uint8Array(12))
            window.crypto.subtle.encrypt({ name: "AES-GCM", iv: iv },
                                         cipherKey, new Uint8Array(exportKey)).then(function(privateKey) {
                var message = { timestamp    : '...'
                              , envelope     : {}
                              , payload      :
                                { privateKey : to_hex(ab2b(privateKey))
                                , iv         : to_hex(iv)
                                }
                              }
                window.crypto.subtle.encrypt({ name: "AES-GCM", iv: iv },
                                             symmetricKey,
                                             b2ab(JSON.stringify(privateGlobal))).then(function(privateData) {
                    message.payload.privateData = to_hex(ab2b(privateData))
                    message.payload.publicData = publicGlobal

                    var nonce = window.crypto.getRandomValues(new Uint8Array(12))
                    var combo = JSON.stringify(personaID + ':' + to_hex(nonce) + ':' + JSON.stringify(message.payload))
                    window.crypto.subtle.sign({ name: "ECDSA", hash: { name: "SHA-256" } },
                                              pair.privateKey, b2ab(combo)).then(function(signature) {
                        message.envelope = { signature: to_hex(ab2b(signature))
                                           , nonce: to_hex(nonce)
                                           }

                        console.log('PUT /users/' + personaID)
                        console.log(JSON.stringify(message, null, 2))
                    })
                })
            })
        })
    })

