# Principles of using the Brave Vault
The Brave _vault_ is a private repository for your browsing information.
Because you may use multiple browsers,
the vault also allows browsers to sync data.

The vault is carefully designed so as to "know" as little as possible about you and your browsing habits.
In order to understand the limitations of this design,
we need to examine the basic principles of the vault.

## Personas and Sessions
The central data element in the vault is a _persona_ -- sometimes referred to as a _user_ of the system.
A persona is meant to identify a set of your browsing behaviors,
without identifying you.
Each Brave-capable browser is free to create its own persona,
or to use an existing persona created by another browser.

If you configure the same persona for multiple browsers
(e.g., your desktop at work, your tablet at home, your phone when mobile),
then this provides a more complete picture of your browsing activities.
You may view this as a good thing or a bad thing -- and that's fine -- you decide.

### Creating a Persona
The `PUT /v1/users/{userId}` operation both
creates an entry for a persona,
and updates the information in that entry.
A `userId` is a 122-bit pseudo-random number commonly known as a
[UUID v4](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_.28random.29) value.
Note that it is generated by the browser,
not the server.
For example,
[Stack Overflow](http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript#2117523)
gives a browser-based example:

    'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = window.crypto.getRandomValues(new Uint8Array(1))[0]%16|0, v = c == 'x' ? r : (r&0x3|0x8)
        return v.toString(16).toUpperCase()
    })

In addition to generating the `userId`,
the browser generates a `masterKey` and a `signingPair`:

    window.crypto.subtle.generateKey({ name: 'AES-GCM', length: 256 }, true
                                    , ['encrypt', 'decrypt']).then(function (masterKey) { ... })

    window.crypto.subtle.generateKey({ name: 'ECDSA', namedCurve: 'P-256' }, true
                                    , [ 'sign', 'verify' ]).then(function (signingPair) { ... })

Both the `masterKey` and `signingPair.privateKey` must be securely persisted in the browser.

When creating a persona,
the HTTP body is:

    { header            :
      { signature       : '...'
      , nonce           : '...'
      }
    , payload           :
      { version         : 1
      , publicKey       : '...',
      , privateKey      :
        { encryptedData : '...',
        , iv            : '...'
        }
      }
    }

The `version` property is self-explanatory.

The `publicKey` property is the hexadecimal string representation of the public key used to verify digital signatures.
The vault verifies the signature as the authorization check for an operation.

The `privateKey` property is an object with an `iv` parameter used with the `masterKey` to generate the `encryptedData`
parameter.

The `signature` and `nonce` properties are used to ensure that the client actually knows the `signing.privateKey`:

    var ab2hex = function (ab) {
      var buffer = []
      var view = new Uint8Array(ab)

      for (var i = 0; i < ab.byteLength; i++) buffer[i] = view[i]
      return new Buffer(buffer).toString('hex')
    }

    var str2ab = function (s) {
      var buffer = new Uint8Array(s.length)

      for (var i = 0; i < s.length; i++) buffer[i] = s.charCodeAt(i)
      return buffer
    }

        
    window.crypto.subtle.exportKey('jwk', pair.privateKey).then(function (privateKey) {
      window.crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, self.runtime.masterKey,
                                       obj2ab(privateKey)).then(function (ciphertext) {
        /* the publicKey is not sent as an x/y pair, but instead is a concatenation (the 0x04 prefix indicates this),
           and the privateKey is encrypted using the masterKey and a one-time initialization vector */

        window.crypto.subtle.exportKey('jwk', pair.publicKey).then(function (publicKey) {
          var iv = window.crypto.getRandomValues(new Uint8Array(12))
          var message = { header           : {}
                        , payload          : 
                          { version        : 1
                          , publicKey      : '04' +
                                              new Buffer(publicKey.x, 'base64').toString('hex') +
                                              new Buffer(publicKey.y, 'base64').toString('hex')
                          , privateKey      : 
                            { encryptedData : ab2hex(ciphertext)
                            , iv            : ab2hex(iv)
                            }
                          }
                        }

          message.payload.privateKey = { encryptedData: ab2hex(ciphertext) , iv: ab2hex(iv) }

          var nonce = (new Date().getTime() / 1000).toString()
          var combo = JSON.stringify({ userId: userId, nonce: nonce, payload: message.payload })
          window.crypto.subtle.sign({ name: 'ECDSA', namedCurve: 'P-256', hash: { name: 'SHA-256' } },
                                    pair.privateKey, str2ab(combo)).then(function(signature) {
            message.header = { signature: ab2hex(signature), nonce: nonce }
    
            console.log('PUT /v1/users/' + userId)
            console.log(JSON.stringify(message, null, 2))
          })
        })
      })
    })

In order for the `nonce` to be considered valid,
it must be "close" to the vault's notion of the current time.
In order to avoid time synchronization issues,
the vault will include its own `nonce` property in the results of these operations:

    GET /v1/ping

    GET /v1/users/{userId}
    PUT /v1/users/{userId}

    GET /v1/users/{userId}/sessions
    GET /v1/users/{userId}/sessions/{sessionId}/types    
    GET /v1/users/{userId}/sessions/{sessionId}/types/{type}
    PUT /v1/users/{userId}/sessions/{sessionId}/types/{type}

The browser is responsible for correlating this value to its own notion of the current time,
e.g.,

    var offset = result.header.nonce - new Date().getTime()
    ...
    var nonce = new Date().getTime() + offset

To summarize:

* Whenever the browser stores something encrypted in the vault,
it encrypts data using the `masterKey` and a one-time initialization vector.
The `masterKey` is never stored in the vault:
only the browser that created the persona
-- along with any other browsers that you configure to be authorized --
are able to decrypt the actual value.

* Whenever the browser stores something in the vault,
it uses the `signingPair.privateKey` to generate a signature over a hashed value to allow the vault to determine if
the browser is authorized.

### Creating a Session
In addition to selecting a persona,
a browser must also create a _session_.
As with the `userId`,
a `sessionId` is a UUID v4 string that is generated by the browser.

Although the browser determines the lifetime of the session -- the common practice is for each client to to generate
a lifetime `sessionId`.
The reason is that the `sessionId` is used as a key to store browser-specific information such as history.

The `PUT /v1/users/{userId}/sessions/{sessionId}/types/{type}` operation
creates or updates that `type` of information for that particular session of the persona.


### Joining a Persona
When the user wishes to configure an additional browser (the "new" browser)
to use the same persona in use by an existing browser (the "old" browser),
the "new" browser needs to be told:

* the persona-identifier (`userId`)

* the `masterKey` (for data encryption and to decrypt the encrypted `signingPair.privateKey` in the vault)

The easiest way to do this is to have the "old" browser generate a [QR code](https://en.wikipedia.org/wiki/QR_code)
of the form:

    persona://.../v1/{userId}?m={masterKey}&p={signingPair.privateKey}

For example:

    var url = 'persona://.../v1/' + userId
    window.crypto.subtle.exportKey('jwk', masterKey).then(function (exportKey) {
      url += '?m=' + encodeURIComponent(JSON.stringify(exportKey))
      console.log('QR code: ' + url)
    })

<!--
persona://127.0.0.1:3000/v1/BCF88057-07ED-4D7C-93DF-7A8BAC70ECEA?m=%7B%22kty%22%3A%22oct%22%2C%22ext%22%3Atrue%2C%22alg%22%3A%22A256GCM%22%2C%22key_ops%22%3A%5B%22encrypt%22%2C%22decrypt%22%5D%2C%22k%22%3A%22vG3p0niH675aHV5b-0YJzMtxT2d9S9xwNIRqwJ4fHQk%22%7D

http://www.qrstuff.com/
http://dopiaza.org/tools/datauri/index.php
 -->

<img src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADIAQMAAACXljzdAAAABlBMVEX///8AAABVwtN+AAAACXBIWXMAAA7EAAAOxAGVKw4bAAADlklEQVRYw+2XvY3rOhBGR1CgTGyAANtQ5pboBky5AbMlZWqDABuQMwWE5x2ujXtfurMbXkYSjiBS8/N9I5F/y7acam7Xrbj63EsMWVVH1WIks4wr92MO902zxEvN4ypmwmUbzpr9bfHSZvFpzOdPSHiJd17ES1j5jh+SNmxhbU5bLOn8GSEG4+MyKgcu0d+mcPwvOt8lPT/+uvtYH0v9XP3N3HdJX7oKqZmlSd8ilb/1813iSLTMS4k1a4nFnSU2d5ZfJ6zk0+mlPrUempWo86CVTJTna6nq40Sp36n45jYrGZQtOLDzwzaujdKKMmxiJPOFzLmz39ON7UZF+PfHWMjAIcf7KZHM8fnXXqOPyUrcGTQ8pDgyVaJcld5+qpUMu6TxTgj9sOtaht3zlJkIZ613tiCivXUmQkI0rGQigGlvKMX01dYtEQ8robezHmw2Hj0QcZFEO4mRUHVR0sbbbxcv/rqNxPTr1Cayh9XPpLfqSd6faC2NJ0YiSxN9TEV6WPkIAkF+yq+TmVQ1meqBnFclcz4SdTshUekkvr0HEeDxU1Im4rSuJalP3lGevkfp09sWMpOvekhLhagf9Xl619vJSOgaRSmUfKkeJU66qr4VyUBwKte6aI9E9CiYw5/8GAipyTigjwHPWsfXJSjuZSV9H6Sa1NwwLs2bxDJPViKL8mIJR9Au2hEf0Nc73QbCvJDC/Sypub2u4fnWs2Il3FPN9ODtIlKGrWIoi5XI5cuUQg4PRhA2825c7WRBw/qLyfZIz1GYo56/T+beM1ccnpaEEPVMA4iZ4AsPKtNftfvpQh3ET4V8nwzILjLRh0V0MxwMUPW5mcne5zkGGuqcifFJ1L1cxEjInNRXL1QqE3NYxIXVTFDYI9wZQcgKYaWJaOylGAm+HutxaeJvtLV3mySU20r4iSDVl7Dqk9k45LMf/T0jWYg24cXjoa+pRc0nLv32EhNhBtQnbx9fk0+FApJ+ayZ0Y8KYQ97r11Sz+quZzEvIjZEXFdsZK/kvoVXeFW8gXen7pcPs+Bd7LD59nOl3idAwfuB7PM+k1kXu41k2Ij06Vbsv9Im4SZknK8FFV/qHsf/W6/yq4pjFrKT/N/a3J6wUX7jvIZf5YiaX2vWBEsjIBQXqRV8/IZl9EDK3oUC4zMEA9hPC+Ioc3jd+4WnEVD+zsoUwX5duqqgjhUps80cpLMR99CHql5TlDZxPMZJ/63fXf+fUEqmMdj1IAAAAAElFTkSuQmCC' width='405' height='405' />

Once the QR code is generated,
the "new" browser can use its camera and a QR decoder to derive the three elements pertaining to the persona.

If the "new" browser does not have a camera,
then the "old" browser should save a file to a USB stick on its platform,
which is subsequently moved to the platform with the "new" browser,
imported in to the "new" browser,
and then wiped.

## Managing State
The vault manages two kinds of state:

* session state, that is session-specific; and,

* global state, that is session-independent.

It is up to the browser to determine which kind of state to associated with browser-specific data.

### Session State
The `GET /v1/users/{userId}/sessions` operation returns an array of all state for all of the sessions for the persona.
Because there may be many results,
the operation has two optional `GET query` parameters,
`limit` and `timestamp`.

The `limit` parameter indicates the maximum number of entries to return.

The `timestamp` parameter is an opaque string.
On the first call to `GET /v1/users/{userId}/sessions`,
the parameter isn't specified.
On subsequent calls,
the value should be equal to the `timestamp` property of the final element in the results array.
Eventually,
the results array will be zero-length,
and all entries have been returned.

The `GET /v1/users/{userId}/sessions/{sessionId}/types` operation returns an array of all state for a particular
session of the persona.
The operation has two optional `GET query` parameters,
`limit` and `timestamp`,
with the usual semantics.

The `GET /v1/users/{userId}/sessions/{sessionId}/types/{type}` operation returns the state of for a particular
`type` of information for that particular session of the persona.

The `PUT /v1/users/{userId}/sessions/{sessionId}/types/{type}` operation creates or updates that `type` of information for
that particular session of the persona.

When upserting state information,
the HTTP body is:

    { header          :
      { signature     : '...'
      , nonce         : '...'
      },
    , payload         :
      { iv            : '...'
      , encryptedData : '...'
      }
    }

For example:

    var history = { ... }

    var iv = window.crypto.getRandomValues(new Uint8Array(12))
    window.crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv },
                                 masterKey, str2ab(JSON.stringify(history))).then(function(encryptedData) {
      var message = { header          : {}
                    , payload         :
                      { iv            : ab2hex(iv)
                      , encryptedData : ab2hex(encryptedData)
                      }
                    }
      var nonce = (new Date().getTime() / 1000).toString()
      var combo = JSON.stringify({ userId: userId, nonce: nonce, payload: message.payload })
      window.crypto.subtle.sign({ name: 'ECDSA', namedCurve: 'P-256', hash: { name: 'SHA-256' } },
                                signingPair.privateKey, str2ab(combo)).then(function(signature) {
        message.header = { signature: ab2hex(signature), nonce: nonce }

        console.log('PUT /v1/users/' + userId + '/sessions/' + sessionId + '/types/history')
        console.log(JSON.stringify(message, null, 2))
      })
    })

Note that the vault verifies the digital signature in order to ensure that the operation is authorized.
The `nonce` property is a timestamp indicating the number of seconds since the UNIX epoch.
In order for the `nonce` to be considered valid,
it must be "close" to the vault's notion of the current time.
In order to avoid time synchronization issues,
the vault will include its own `nonce` property in the results of many operations.
The browser is responsible for correlating this value to its own notion of the current time,
e.g.,

    var offset = results.header.nonce - new Date().getTime()
    ...
    message.header.nonce = new Date().getTime() + offset

### Global State
The `PUT /v1/users/{userId}` operation,
in addition to creating an entry for a persona,
also updates the information in that entry.

When updating information,
the HTTP body is:

    { timestamp       : '...'
    , header          :
      { signature     : '...'
      , nonce         : '...'
      },
    , payload         :
      { iv            : '...'
      , encryptedData : '...'
      , plaintextData : { ... }
      }
    }

The procedure for generating the `header` and `payload` properties are the same,
with one exception: there is both a `payload.encryptedData` property and a `payload.plaintextData` property.
The latter is an arbitrary JSON object with plaintext information.

This operation updates information shared between all applications for the correpsonding user entry,
using an advisory locking scheme.
To successfully update the shared information,
the browser must:

1. Use the `GET /v1/users/{userId}` operation to retrieve the current information; then,

2. Modify the returned "payload" as appropriate; then,

3. Use the `PUT /v1/users/{userId}` operation with the previously-returned `timestamp` and the modified `payload`.

4. If HTTP code 422 is returned, go back to Step 1; otherwise,

5. Optionally:
locally-persist the newly-returned `timestamp`
so as to skip Step 1 the next time a state update is desired.

This allows multiple applications to (patiently) coordinate their actions in upgrading the shared information.
However, if an application must universally overwrite the shared information, it omits the "timestamp" parameter.

    var publicGlobal   = { ... }
      , privateGlobal  = { ... }

    var iv = window.crypto.getRandomValues(new Uint8Array(12))
    window.crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv },
                                 masterKey, str2ab(JSON.stringify(privateGlobal))).then(function(encryptedData) {
      var message = { timestamp       : '...'
                    , header          : {}
                    , payload         :
                      { iv            : ab2hex(iv)
                      , encryptedData : ab2hex(encryptedData)
                      , plaintextData : publicGlobal
                      }
                    }
      var nonce = (new Date().getTime() / 1000).toString()
      var combo = JSON.stringify({ userId: userId, nonce: nonce, payload: message.payload })
      window.crypto.subtle.sign({ name: 'ECDSA', namedCurve: 'P-256', hash: { name: 'SHA-256' } },
                                signingPair.privateKey, str2ab(combo)).then(function(signature) {
        message.header = { signature: ab2hex(signature), nonce: nonce }

        console.log('PUT /v1/users/' + userId)
        console.log(JSON.stringify(message, null, 2))
      })
    })

